<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KIP | Confluent Japan Community</title><link>https://confluent-jp.github.io/community/tag/kip/</link><atom:link href="https://confluent-jp.github.io/community/tag/kip/index.xml" rel="self" type="application/rss+xml"/><description>KIP</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja-jp</language><lastBuildDate>Sun, 06 Aug 2023 00:00:00 +0000</lastBuildDate><image><url>https://confluent-jp.github.io/community/media/icon_hubade5daff97c80353b10ab16b141ee15_5385_512x512_fill_lanczos_center_3.png</url><title>KIP</title><link>https://confluent-jp.github.io/community/tag/kip/</link></image><item><title>Tiered Storageは何故そんなに重要なのか？</title><link>https://confluent-jp.github.io/community/blog/kip405-why-tiered-storage-important/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://confluent-jp.github.io/community/blog/kip405-why-tiered-storage-important/</guid><description>&lt;h2 id="tiered-storageとは">Tiered Storageとは&lt;/h2>
&lt;p>今年の後半にリリースが予定されている&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/Release&amp;#43;Plan&amp;#43;3.6.0" target="_blank" rel="noopener">Apache Kafka 3.6&lt;/a>には、Tiered Storageと呼ばれるKafkaコミュニティが待ち望んだ新機能が含まれる予定です。この機能は&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-405%3A&amp;#43;Kafka&amp;#43;Tiered&amp;#43;Storage" target="_blank" rel="noopener">KIP-405&lt;/a>として何年も前に登録されたKIPであり、長い期間をかけてようやくリリース目処が経ちました。&lt;/p>
&lt;p>これまでKafkaのデータは常にBrokerのストレージに格納されていましたが、これを二層化して古いセグメントを自動的に退避するという機能です。Kafkaに格納されたイベントをオブジェクトストレージに退避するというプラクティスは一般的であり、これまではKafka Connectコネクタを使って自分で退避させるアプローチを取っていました。これをKafkaネイティブな機能として提供する、その役割をKafka Brokerが行うというものです。クライアントからはこのオペレーションは隠蔽化されており、新しいイベントも古いイベントも同じアプローチでアクセスする事が出来ます。&lt;/p>
&lt;h2 id="tiered-storageの動き---図解">Tiered Storageの動き - 図解&lt;/h2>
&lt;p>これまで通り、クライアントから送られたイベントはkafka Brokerのストレージにセグメント単位で保存されます。セグメントはログファイルであり、ランダムアクセスではなくアペンドでしかデータを足せない為、最も新しいセグメント (Active Segmentと呼ばれます) 以外のファイルは不可変 (Immutable) です。&lt;/p>
&lt;p>Tiered Storageはこのうち古いセグメントを自動的にオブジェクトストレージに退避します。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-1" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_307dc89e1a68d87bc27b49159af2e082.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_0c117106ee083960e7059ed25e9ffecd.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_307dc89e1a68d87bc27b49159af2e082.webp"
width="760"
height="290"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>中では新しくRemoteLogManagerと呼ばれるプロセスが、これまでのLogManagerに近い役割を果たしつつリモートストレージにコピーし、合わせてリモートストレージのインデックス状態のキャッシュを保持します。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-2" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_ed30da300d0b9b691d188362efbc7e4f.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_d4ef38034777db186c40e196ccf45f74.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_ed30da300d0b9b691d188362efbc7e4f.webp"
width="760"
height="277"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>上にあるように、Broker側の保全期間 (Retention Period) を超過しセグメントが削除された後も、リモートストレージにはそのコピーが残ります。ストレージの動きはこれだけで、リモートからローカルにセグメントが戻ってくる様な事はありません。これまでのLog Managerの役割もそのままで、ローカルのログは今まで通り管理されます。&lt;/p>
&lt;p>ほとんどのユースケースでは、クライアントは最新のセグメントに集中してアクセスします。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-3" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_13555c5a91b8f7799d7e3a3c89dd36dd.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_38b70ca4b82c8226d2b8975dc87ab4fb.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_13555c5a91b8f7799d7e3a3c89dd36dd.webp"
width="760"
height="277"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
書き込みは当然最新であるActive Segmentにしか発生しませんが、読み込みも多少のラグはありながらもほぼ最新に近いセグメントへのアクセスとなります。このアクセスはこれまでと何も変わらず、今まで通りBrokerがディスクI/O経由でデータを取得しクライアントに帰します。&lt;/p>
&lt;p>違いは、クライアントが古いセグメントにあるオフセットを指定して読み込みをリクエストした場合です。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-4" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_2a2234b74cfe0781c6e5b4a49c707312.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_0641f49b3b2042ca8b889354eab7f534.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_2a2234b74cfe0781c6e5b4a49c707312.webp"
width="760"
height="288"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>既にBrokerのローカルストレージにはセグメントは存在しませんが、リモートストレージに存在する限りBrokerはデータを取得しクライアントに返すことが出来ます。&lt;/p>
&lt;h2 id="メリット-1---拡張性-scalability">メリット 1 - 拡張性 (Scalability)&lt;/h2>
&lt;p>Kafkaは拡張性に極めて優れたストリーミングプラットフォームであり、原則Brokerノードを追加することにより水平スケールする事ができます。一方、拡張には限界があります。一般的に大規模Kafkaクラスタにおけるボトルネックはネットワーク帯域で、次にストレージと言われています。これらを充分確保出来続ける限りKafkaクラスタは相当規模まで拡張出来ます。Tiered Storageによってストレージ容量の削減とより高度なコントロールが可能になります。&lt;/p>
&lt;p>KafkaにとってそれぞれのTopicの保全期間 (Retention Period) と書き込みスループットは基本的にはバランスゲームです - 高書き込みスループットの場合はストレージ容量の増加を加味してより短い保全期間を指定する必要があります。保全期間のデフォルトでは1週間、通常運用では1日という場合も多くありますが、高負荷のクラスタでは数時間程度に留める事も多くあります。&lt;/p>
&lt;p>kafkaは内部でデータのレプリケーションを行なっています。Replication Factorと呼ばれるこの設定のデフォルトは&lt;code>3&lt;/code>であり、稀に金融やストレッチクラスタ (複数のサイトに跨がる大きなクラスタ) では&lt;code>4&lt;/code>を指定する場合もありますが、ほとんどデフォルトのままではないかと思います。いずれにせよ、その指定分だけデータはレプリケートされるので、必要ディスク容量は増えます。&lt;/p>
&lt;p>例えば100MBpsで書き込みがなされる場合、レプリケーションも考慮するとクラスタ内のネットワーク帯域には300MBps、当然ストレージにも300MBpsのスピードで消費します。保全期間を1日とした場合、100 * 3600 * 3 = 1,080,000MB ≒ 1TBのストレージ容量が必要となります。書き込みスループットが倍になればストレージも倍、当然保全期間を倍にしてもストレージは倍必要になります。&lt;/p>
&lt;p>ストレージがボトルネックになった場合、ディスクを足せば解消しますが、それも限界を超えるとBroker自体を追加する必要が出てきます。Tiered Storageを導入すると、Brokerが必要とするストレージの絶対量を制限できます。同一ハード構成におけるキャパシティを上げ、将来的な拡張性も高く出来ます。&lt;/p>
&lt;h2 id="メリット-2---障害耐性-resiliency">メリット 2 - 障害耐性 (Resiliency)&lt;/h2>
&lt;p>ストレージを分離する事によって障害耐性が上がるというのはピンと来ないかも知れませんが、Tiered Stoargeによる効果と期待は障害耐性の向上にも集まっています。&lt;/p>
&lt;p>Kafkaが何事もなく稼働している限り、またデータが適切にパーティションされている限り、Kafkaクラスタは均一にデータを分散配置し管理出来ます。しかしBrokerのシャットダウンと復帰は必ず発生します。時としてハードやソフトの障害によって、他ではBroker/JVM/Guest OS/Host OS/Host Hardwareのアップグレードによって、クラスタ構成は短期/長期的にその構成が変わります - Kafkaは絶えずメンバーシップを変えつつ稼働し続ける分散システムであり、構成が変わる前提の上で成立している技術です。&lt;/p>
&lt;p>Brokerがクラスタメンバーから外れると、それまでそのBrokerで保全していたデータは必ず何かしらの方法で他のBrokerに再配置されなければデータの保全性が保てません。この為クラスタメンバーシップの変更は、大規模なメタデータの更新と、データの移動を意味します。&lt;/p>
&lt;p>Tiered Storageによって管理/移動対象となるセグメントの物理的な数が減れば、その分クラスタ内で移動するデータ量が減少し、また大量メタデータ更新に伴う二次災害の危険性も減少し、結果としてより安全に、より短い期間にクラスタが正常状態に復帰します。Kafkaクラスタ自体が軽量になればなるだけ、例えばコンテナの様により頻繁に刷新されるランタイム上でKafkaを運用する場合にも大きなメリットとなります。&lt;/p>
&lt;h2 id="メリット-3---リソースの有効活用-resource-utilization">メリット 3 - リソースの有効活用 (Resource Utilization)&lt;/h2>
&lt;p>Kafkaとは基本的にディスクI/Oへの負荷が高いプラットフォームです。これは書き込み/読み込みの発生頻度が高く、またディスクI/Oの有効利用が今回の設計思想に織り込まれています。併せて、Kafkaは原則マルチテナントプラットフォームであり、様々なワークロードが共存し易い (各々のワークロードの影響を受けにくい) ストリーミング基盤です。しかしながらKafkaにも物理的な制約は存在し、ワークロードのニーズ的にはクラスタ自体を分ける事も実際には多くあります。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Tiered Storageへのアクセスは、Kafkaでは珍しくディスクI/OではなくネットワークI/Oへの比重が高い処理となります。例えば長期間実行するバッチ処理 (古いデータなのでTiered Storage経由) と、超低レイテンシな処理が求められるオンライン処理 (新しいデータなのでBrokerから) とではKafkaかかるリソース負荷が全く異なります。これら特性を上手く利用すれば、オンライン処理を実行しながら低負荷でバッチ処理を同一クラスタ内で扱う事も出来ます。&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="おわりに">おわりに&lt;/h2>
&lt;p>Tiered StorageはApache Pulserの様なコンピュートとストレージを完全に切り離す目的で導入される訳ではありません。Kafkaはある意味意図的に原始的な設計をしている点が長所であり、時として短所となり得る技術です。Tiered StoargeはKafkaが本来持つ高スループットかつ低遅延な処理能力を殺す事なく、短所であるディスク容量やディスクI/Oというボトルネックを軽減させ得る可能性を持った非常に有望な機能です。併せて、よりクラウドネイティブな環境で動く機会の増えたKafkaにとって、その新しい環境により適合性の高い機能であるとも言えます。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>例えば長期実行されるバッチ処理が継続してKafkaにアクセスしている状態で、非常にレイテンシ要件の高いオンライン処理が同居する様な場合です。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>当然、充分なネットワーク帯域が確保されている場合には、という条件は付きます。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Exactly Onceとmax.in.flightについて</title><link>https://confluent-jp.github.io/community/blog/idempotent-producer-and-max-inflight/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://confluent-jp.github.io/community/blog/idempotent-producer-and-max-inflight/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>メッセージブローカー界隈でのデリバリー保証はAt Least Once (必ず送信するが1度以上送信する可能性がある) というのが常識であり、データを受け取るConsumer側で冪等性を保証する必要がありました。そのExactly Once SemantisがKafkaでサポートされた時には多くの反響を呼びましたが、この設定は最近DefaultでOnになる程Kafkaコミュニティでは広く利用されています。&lt;/p>
&lt;p>ただこのエンハンスメントにも制限がありました。この制限は後日、ひっそりと一つのPRによって解消されています。話題には上りませんでしたが、この機能が広く利用される上では非常に重要なエンハンスメントでした。&lt;/p>
&lt;h2 id="exactly-once-semantics">Exactly Once Semantics&lt;/h2>
&lt;p>Kafka初期において最も注目を集めたエンハンスメントの一つに&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98&amp;#43;-&amp;#43;Exactly&amp;#43;Once&amp;#43;Delivery&amp;#43;and&amp;#43;Transactional&amp;#43;Messaging" target="_blank" rel="noopener">KIP-98 - Exactly Once Delivery and Transactional Messaging&lt;/a> があります。「メッセージ基盤においてExactly Onceは不可能」という&lt;a href="https://ja.wikipedia.org/wiki/%E4%BA%8C%E4%BA%BA%E3%81%AE%E5%B0%86%E8%BB%8D%E5%95%8F%E9%A1%8C" target="_blank" rel="noopener">二人の将軍問題&lt;/a> 観点からの懐疑的な意見も多く議論を呼びました。そもそもKafkaが唱えるExactly Onceのスコープは何か、そして何がその前提となっているのかについてはKafka初期開発者であるネハさんを始めとして&lt;a href="https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/" target="_blank" rel="noopener">具体的な説明&lt;/a>もたくさんなされています。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>実際のKIPに記載されている設定条件は以下で、これらも同様に適切に設定しない限りは&lt;code>enable.idempotency=true&lt;/code>と設定してもProducerの冪等性を確保する保証はないと記載されています (仮にIdempotent Producerとして動いてPIDに値が設定されているとしても)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">ack&lt;/span>&lt;span class="o">=&lt;/span>all
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">retries &amp;gt; &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">max.inflight.requests.per.connection&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>必ずISRへの同期が完了し、エラー時にはリトライする様にし、かつProducerからの並列送信は許容しない、という条件です。理には適っています。&lt;/p>
&lt;h2 id="kafka-5494">KAFKA-5494&lt;/h2>
&lt;p>&lt;a href="https://github.com/apache/kafka/pull/3743" target="_blank" rel="noopener">KAFKA-5494: enable idempotence with max.in.flight&amp;hellip;&lt;/a> このPRではKIP-98実装における課題の説明と、それに対する解決策が記載されています。具体的には2つの課題への対応が纏まったPRとなっており、結果としてmax.in.flight.requests.per.connectionが1である制限を最大5まで増やす対応となっています。&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>対応としてのポイントは、Brokerとの通信途絶時のProducer側 (Client) のシーケンス番号の採番ルールです。送信エラーとなった場合にはシーケンス番号を採番し直す事により処理を自動復旧すること、また再採番の前に送信処理中のバッチが全て処理済みである確認等が考慮されています。&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="おわりに">おわりに&lt;/h2>
&lt;p>KIPではなくPRとして実装されたこの変更ですが、シーケンス例外が出た際に事後復旧出来るようになる事、max.in.flightを1より大きく指定できる事、より広くIdempotent Producerを利用する上で重要な改善が含まれています。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>オリジナルのデザイン資料は&lt;a href="https://docs.google.com/document/d/11Jqy_GjUGtdXJK94XGsEIK7CP1SnQGdp2eF0wSw9ra8/" target="_blank" rel="noopener">ここ&lt;/a>にあります。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>合わせて&lt;code>OutOfSequenceException&lt;/code>が発生してしまうとクライアント側での後続処理は全て同じ例外が発生する課題についても対応されています。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>またこのPRに関する前提情報や設計については別途&lt;a href="https://docs.google.com/document/d/1EBt5rDfsvpK6mAPOOWjxa9vY0hJ0s9Jx9Wpwciy0aVo/edit" target="_blank" rel="noopener">こちら&lt;/a>にまとめられています。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Queues for Kafkaとは何か?</title><link>https://confluent-jp.github.io/community/blog/kip923-queues-for-kafka/</link><pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate><guid>https://confluent-jp.github.io/community/blog/kip923-queues-for-kafka/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>Apache Kafka® はメッセージキューと比較される事も多く、またメッセージキューとして利用される事も多くあります。&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-932%3A&amp;#43;Queues&amp;#43;for&amp;#43;Kafka" target="_blank" rel="noopener">KIP-932 Queues for Kafka&lt;/a> はそのKafkaに対してネイティブにメッセージキューとして利用する機能性を追加するKIPです。&lt;/p>
&lt;h2 id="consumer-group">Consumer Group&lt;/h2>
&lt;p>Kafkaは仕組み的にはメッセージキューではない、と言うのは語弊があるかも知れません。もう少し正確に説明すると「メッセージの順序保証 (Order Guarantee) を確保する為にスケールする際に制限がある」仕組みを採用しています。この仕組みはConsumer Groupと呼ばれ、Kafkaにおけるデータの分離単位であるPartition単位にメッセージの順序保証をするアプローチです。&lt;/p>
&lt;p>&lt;a href="https://www.confluent.io/blog/dynamic-vs-static-kafka-consumer-rebalancing/" target="_blank" rel="noopener">Consumer Group&lt;/a>はアプリケーションが任意に指定することができ、その管理はKafka Brokerにて稼働するConsumer Group Coordinatorというプロセスが行います。Consumer Group CoordinatorはGroupメンバーの追加/削除の自動検知とリバランスを担当し、Consumer Groupメンバーの追加/離脱やこれらの死活監視、グループメンバーシップをトリガーとした処理のリバランス (メンバーへのPartitionのリアサイン) を自動的に行います。Consumer Groupの仕組みは、ストリームアプリケーションの可用性と拡張性に重要な役割を担っています。&lt;/p>
&lt;p>一方、メッセージ処理の順序保証を前提としている為、 Partitionに複数のConsumerを設定する事が出来ず、この為Topicに指定するPartition数が並列処理能力の拡張性を決定します。 また、そもそも順序性の保証が不要なユースケースであってもConsumer Groupのルールに則らないといけないという制約は存在します。大容量のデータ処理 and/or 非常に柔軟な拡張性の制御が要求されるようなユースケースでは課題となり得る、というより歯痒い条件と見られる事もあります。&lt;/p>
&lt;h2 id="これまでのアプローチ">これまでのアプローチ&lt;/h2>
&lt;p>ほとんどのユースケースでは6、10、12といったベストプラクティスに沿ったPartition数を指定する事により、充分な並列処理能力と拡張性を確保することが出来ます。仮にどれだけの並列処理能力が求められるとしても、将来的にも1処理に対して24インスタンスによる並列処理が必要となる事が無いのであれば、Partition数を24としておけば安全圏です。一般的にはこのアプローチが多く取られます。&lt;/p>
&lt;p>&lt;a href="https://github.com/line/decaton" target="_blank" rel="noopener">LINE Decaton&lt;/a> はLINE Corporationが社内利用の為に開発しオープンソース化したKafkaライブラリです。大容量のストリーム処理を安定的に、かつKey単位の順序保証とAt Least Onceのデリバリを保証する事が可能です。&lt;/p>
&lt;p>&lt;a href="https://github.com/confluentinc/parallel-consumer" target="_blank" rel="noopener">Confluent Parallel Consumer&lt;/a> はConfluentがオープンソースで提供している分散処理Kafkaライブラリです。こちらもKey単位での順序保証をしており、&lt;a href="https://www.confluent.io/blog/introducing-confluent-parallel-message-processing-client/" target="_blank" rel="noopener">順序保証しない設定を含め柔軟に処理構成を変更&lt;/a>することが出来ます。&lt;/p>
&lt;h2 id="queue-for-kafka---kafka-nativeなアプローチ">Queue for Kafka - Kafka Nativeなアプローチ&lt;/h2>
&lt;p>Queues for KafkaはConsumer Groupと異なる新しいグループ化を提供するものです。Share Groupと呼ばれ、Partition数に影響なくメンバーを追加することが出来ます。&lt;/p>
&lt;p>Shared Groupは全く異なるインターフェースではなく、これまでのConsumer Groupと同列に扱われ、&lt;code>group.type&lt;/code>を&lt;code>share&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>と設定する事によって指定します。Consumer Groupの場合、Partition数を超えるメンバーを指定しても処理に参加できなかったり、Partition数をきっちり割り切れるメンバー数でないとアサインメントに偏りが出ますが、Share Groupの場合は任意のメンバー数を指定する事により均一かつ水平にスケールします。&lt;/p>
&lt;p>Consumer Groupと構成も同じで、BrokerのうちConsumer Group CoorinatorではなくShare Group Coordinatorを司るプロセスがグループメンバーの死活監視、リバランス等をConsumer Group同様に実施します。アプリケーション観点でもデプロイ観点でも、Consuemr Groupとの差はなく、あくまでプロパティ設定するのみでグループの振る舞いを変えることができます。&lt;/p>
&lt;h2 id="おわりに">おわりに&lt;/h2>
&lt;p>Kafkaというはそのシンプルな設計ゆえに、十分理解しないと活用が難しいイメージがありました。ただこのシンプルさによってスケーラビリティとあらゆるユースケースでの活用することができ、Kafkaの理解を深める事はより良い設計をする上で非常に重要です。KIP-932は、Kafka誕生から変わることの無かったConsumer Groupというアプローチとは異なるデータアクセスのパターンに対する変更という意味では非常に興味深いKIPです。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;code>group.type&lt;/code>は新しいプロパティ。デフォルトは&lt;code>consumer&lt;/code>であり、この指定だと通常通りConsumer Groupとして機能する。デフォルトは&lt;code>consumer&lt;/code>である為下位互換性あり。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>