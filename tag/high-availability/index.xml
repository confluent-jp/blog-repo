<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>High Availability | Confluent Japan Community</title><link>https://confluent-jp.github.io/community/tag/high-availability/</link><atom:link href="https://confluent-jp.github.io/community/tag/high-availability/index.xml" rel="self" type="application/rss+xml"/><description>High Availability</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja-jp</language><lastBuildDate>Tue, 15 Aug 2023 00:00:00 +0000</lastBuildDate><image><url>https://confluent-jp.github.io/community/media/icon_hubade5daff97c80353b10ab16b141ee15_5385_512x512_fill_lanczos_center_3.png</url><title>High Availability</title><link>https://confluent-jp.github.io/community/tag/high-availability/</link></image><item><title>Confluent Cluster Linkingの仕組みについて</title><link>https://confluent-jp.github.io/community/blog/cluster-linking-demystified/</link><pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate><guid>https://confluent-jp.github.io/community/blog/cluster-linking-demystified/</guid><description>&lt;h2 id="クラスタ間のレプリケーション---一般的なアプローチ">クラスタ間のレプリケーション - 一般的なアプローチ&lt;/h2>
&lt;p>クラスタ間でデータのレプリケーションのニーズは古くからあり、DRや組織内のグループ会社間/事業部間の部分的なデータ共有、または&lt;a href="https://www.uber.com/en-JP/blog/kafka/" target="_blank" rel="noopener">UberさんのActive-Active双方向レプリケーション&lt;/a>の様な使い方もあります。いずれにせよ、何かしらの形でKafkaクラスタから他のクラスタにデータをレプリケートするという手法は変わらず、また利用できるツールも (多少の機能差異はありながらも) 基本的に同じアプローチを取っています。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Replicator Mechanism" srcset="
/community/media/blogs/cluster-linking-demystified/replicator-mechanism_hua771e280c70cf025bf445644156bacea_137607_6a7dc20682ffb664106b15d8d7a60f6e.webp 400w,
/community/media/blogs/cluster-linking-demystified/replicator-mechanism_hua771e280c70cf025bf445644156bacea_137607_68b65292a9a164eca0756f26b403592e.webp 760w,
/community/media/blogs/cluster-linking-demystified/replicator-mechanism_hua771e280c70cf025bf445644156bacea_137607_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/cluster-linking-demystified/replicator-mechanism_hua771e280c70cf025bf445644156bacea_137607_6a7dc20682ffb664106b15d8d7a60f6e.webp"
width="760"
height="395"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>基本的なアプローチはどのレプリケーションツールでも同じで、Producer/Consumerの両方を司るKafka Connectコネクタとして稼働します。SourceクラスタのTopicからConsumeし、DestinationクラスタのTopicにProduceする、理解し易いアプローチだと思います。当然SourceとDestinationのTopicは別々のものなのでPartition数を変える事も出来ますし、一般的なコネクタ同様&lt;a href="https://docs.confluent.io/platform/7.4/connect/transforms/overview.html" target="_blank" rel="noopener">SMT&lt;/a>を利用する事も出来ます。&lt;/p>
&lt;p>同時に、Kafkaクラスタの外で双方にアクセス出来るコンポーネントを別途運用する必要性もあります。レプリケーションツールとKafkaブローカー間にはペイロードの圧縮/解凍処理を挟み、独立したConsume/Produce処理となる為レイテンシも比較的高くなります。またKafkaクラスタ同士がお互いを認識している訳ではなく、それぞれのクラスタに存在するTopic同士も機械的な関連性はありません。当然双方のTopicのConsumer Offsetは全く独立して管理されている為、TopicにアクセスするConsumerをクラスタを跨いで移動させる場合には、何かしらの方法でConsumer Offsetを変換する必要性も発生します。&lt;/p>
&lt;h2 id="cluser-linking---クラスタを跨いだreplica-fetching">Cluser Linking - クラスタを跨いだReplica Fetching&lt;/h2>
&lt;p>Confluent Cluster Linkingのアプローチは大きく異なります。結果としてConsumer Offsetを含め全てのTopicに関するメタデータを完全に同期した状態でデータのレプリケーションが可能です。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Cluster Linking Mechanism" srcset="
/community/media/blogs/cluster-linking-demystified/cluster-linking-mechanism_hu230bfaae51528d07c36b594b0b4778bf_129114_43868967e287aedf92cc92b6a4d38ff2.webp 400w,
/community/media/blogs/cluster-linking-demystified/cluster-linking-mechanism_hu230bfaae51528d07c36b594b0b4778bf_129114_d74af5d4933c58bf63cfd98a36755bff.webp 760w,
/community/media/blogs/cluster-linking-demystified/cluster-linking-mechanism_hu230bfaae51528d07c36b594b0b4778bf_129114_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/cluster-linking-demystified/cluster-linking-mechanism_hu230bfaae51528d07c36b594b0b4778bf_129114_43868967e287aedf92cc92b6a4d38ff2.webp"
width="760"
height="404"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>仕組みとしては、同一クラスタ内におけるKafkaのレプリケーションの仕組みに近く、&lt;a href="https://www.confluent.io/ja-jp/blog/multi-geo-replication-in-apache-kafka/" target="_blank" rel="noopener">Replica Fetcherと近い形でDestinationクラスタにあるBrokerがクラスタ境界を跨いでフェッチする&lt;/a>形でレプリケーションを行います。処理を仲介するものも、ワークロードの何かしらの受け渡しの様な処理も無いため、スループットも高く、また低レイテンシなレプリケーションが可能です。&lt;/p>
&lt;p>当然仲介用のConnectクラスタ等別途立ち上げる必要はありません。リンクの設置も、SourceもしくはDestinationクラスタであるConfluent CloudもしくはPlatformに対してリンク作成コマンドを実行すれば完了します。&lt;/p>
&lt;h2 id="特徴と注意点">特徴と注意点&lt;/h2>
&lt;p>先にメリットについては記載しましたが、非同期レプリケーションではありながらSourceとDestinationのデータ差 (オフセット) がこれまでのアプローチよりかなり小さく、また安定的に同期出来るので、DR等の適用時において復旧/欠損対象となるデータ量を限定する事が出来ます。メタデータごと完全に同期しているのでクラスタ間のデータギャップやその復旧時の運用負荷も下がります。フェイルオーバーを考えると、Cluster Linkingを利用した場合にはオペレーションをかなり簡素化出来るのが特徴です。&lt;/p>
&lt;h3 id="注意点-1---障害時にデータの欠損は起こり得る">注意点 1 - 障害時にデータの欠損は起こり得る&lt;/h3>
&lt;p>Cluster LinkingはMirrorMaker2等と比べると、確かに低レイテンシでデータの同期が可能です。しかしながらあくまで同期ではなく非同期のレプリケーションである為、RPO (Recovery Point Objective: 目標復旧地点) は0ではありません。Sourceクラスタにおいて、「書き込み完了と判断された後」かつ「その変更がDestinationクラスタ側からフェッチされるまで」にSourceクラスタがダウンしてしまう可能性はあり、この条件に合致する差分はSourceが再度復旧出来るまでアクセス出来ません。&lt;/p>
&lt;h3 id="注意点-2---topicはpartition数を含め完全一致">注意点 2 - TopicはPartition数を含め完全一致&lt;/h3>
&lt;p>DestinationクラスタにレプリケートされたTopicは&lt;code>Mirror Topic&lt;/code>と呼ばれる少し特殊なTopicです。具体的には：&lt;/p>
&lt;ul>
&lt;li>全Partitionのイベント数、イベント順序、各イベントのデータが全てSource Topicと全く同じとなる。&lt;/li>
&lt;li>Read OnlyでありDestinationクラスタ内から書き込み不可。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>
となります。&lt;/li>
&lt;/ul>
&lt;p>この為、例えばSourceクラスタのTopicからSMTを使って特定フィールドをマスキングしたり、Sourceと異なるPartition数をDestinationで指定する事は出来ません。&lt;/p>
&lt;h3 id="注意点-3---フェイルオーバー後の復旧はフェイルフォワードを推奨">注意点 3 - フェイルオーバー後の復旧はフェイルフォワードを推奨&lt;/h3>
&lt;p>Cluster LinkingではDR時にフェイルオーバーした際、基本的にDRであったクラスタを今度は本番と位置付けるようコマンドが整備されています。例えば東京リージョン (Prod) から大阪リージョン (DR) へのフェイルオーバー時に、大阪が本番リージョンとして機能します。その後東京リージョンが復旧した場合、フェイルバックするのではなく今度は東京をDRとして継続オペレーションを実施することを推奨しています。&lt;/p>
&lt;h2 id="おわりに">おわりに&lt;/h2>
&lt;p>上記に注意点を幾つか並べましたが、どれもCluster Linkingの欠点と言うよりは特性であり、つまりこの特性を充分理解した上でレプリケーション戦略を立てる事が大事です。&lt;/p>
&lt;ul>
&lt;li>注意点 1 - これは非同期レプリケーションである限り避けようがありません。逆に、非同期なのでSourceクラスタに対する書き込みレイテンシには影響を与えないメリットもあります。&lt;/li>
&lt;li>注意点 2 - 通常のReplica Fetcherの仕組みと近いと考えると当然で、バイトレベルで同一のデータをDestinationクラスタ上に持てるというメリットを考えると納得出来る制約だと思います。&lt;/li>
&lt;li>注意点 3 - これは意見が分かれるところかも知れません。データ基盤全体におけるBC戦略はKafkaのみのルールで決めれるものでは無いので、許容出来ないユースケースは多いと思います。ただ作業の手間が増えるだけで、フェイルバックする事は不可能ではありません。&lt;/li>
&lt;/ul>
&lt;p>他にも場合によってはMirrorMaker2やConfluent Replicatorの方が理に適った選択肢であるケースはあり、実際にもCluster LinkingではなくConfluent Replicatorを採用されるユーザーもいます。確かにCluster Linkingは画期的なレプリケーション機能ではありますが、その特性を理解した上で採用を判断する事が (何事に言える事ですが) 重要です。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>当然DR時にはMirror Topicを元にオペレーションを再開するので、その際は&lt;code>kafka-mirrors --failover&lt;/code>コマンドで書き込み出来るよう切り替えます。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Tiered Storageは何故そんなに重要なのか？</title><link>https://confluent-jp.github.io/community/blog/kip405-why-tiered-storage-important/</link><pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><guid>https://confluent-jp.github.io/community/blog/kip405-why-tiered-storage-important/</guid><description>&lt;h2 id="tiered-storageとは">Tiered Storageとは&lt;/h2>
&lt;p>今年の後半にリリースが予定されている&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/Release&amp;#43;Plan&amp;#43;3.6.0" target="_blank" rel="noopener">Apache Kafka 3.6&lt;/a>には、Tiered Storageと呼ばれるKafkaコミュニティが待ち望んだ新機能が含まれる予定です。この機能は&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-405%3A&amp;#43;Kafka&amp;#43;Tiered&amp;#43;Storage" target="_blank" rel="noopener">KIP-405&lt;/a>として何年も前に登録されたKIPであり、長い期間をかけてようやくリリース目処が経ちました。&lt;/p>
&lt;p>これまでKafkaのデータは常にBrokerのストレージに格納されていましたが、これを二層化して古いセグメントを自動的に退避するという機能です。Kafkaに格納されたイベントをオブジェクトストレージに退避するというプラクティスは一般的であり、これまではKafka Connectコネクタを使って自分で退避させるアプローチを取っていました。これをKafkaネイティブな機能として提供する、その役割をKafka Brokerが行うというものです。クライアントからはこのオペレーションは隠蔽化されており、新しいイベントも古いイベントも同じアプローチでアクセスする事が出来ます。&lt;/p>
&lt;h2 id="tiered-storageの動き---図解">Tiered Storageの動き - 図解&lt;/h2>
&lt;p>これまで通り、クライアントから送られたイベントはkafka Brokerのストレージにセグメント単位で保存されます。セグメントはログファイルであり、ランダムアクセスではなくアペンドでしかデータを足せない為、最も新しいセグメント (Active Segmentと呼ばれます) 以外のファイルは不可変 (Immutable) です。&lt;/p>
&lt;p>Tiered Storageはこのうち古いセグメントを自動的にオブジェクトストレージに退避します。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-1" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_307dc89e1a68d87bc27b49159af2e082.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_0c117106ee083960e7059ed25e9ffecd.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-1_hu2024f9fb0e264eb23f1f5629f1888bef_131836_307dc89e1a68d87bc27b49159af2e082.webp"
width="760"
height="290"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>中では新しくRemoteLogManagerと呼ばれるプロセスが、これまでのLogManagerに近い役割を果たしつつリモートストレージにコピーし、合わせてリモートストレージのインデックス状態のキャッシュを保持します。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-2" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_ed30da300d0b9b691d188362efbc7e4f.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_d4ef38034777db186c40e196ccf45f74.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-2_hu86fab6f33ca7c672a829674acdc1ce76_168812_ed30da300d0b9b691d188362efbc7e4f.webp"
width="760"
height="277"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>上にあるように、Broker側の保全期間 (Retention Period) を超過しセグメントが削除された後も、リモートストレージにはそのコピーが残ります。ストレージの動きはこれだけで、リモートからローカルにセグメントが戻ってくる様な事はありません。これまでのLog Managerの役割もそのままで、ローカルのログは今まで通り管理されます。&lt;/p>
&lt;p>ほとんどのユースケースでは、クライアントは最新のセグメントに集中してアクセスします。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-3" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_13555c5a91b8f7799d7e3a3c89dd36dd.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_38b70ca4b82c8226d2b8975dc87ab4fb.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-3_hufec61c00674d614f5445ee3899763482_184498_13555c5a91b8f7799d7e3a3c89dd36dd.webp"
width="760"
height="277"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
書き込みは当然最新であるActive Segmentにしか発生しませんが、読み込みも多少のラグはありながらもほぼ最新に近いセグメントへのアクセスとなります。このアクセスはこれまでと何も変わらず、今まで通りBrokerがディスクI/O経由でデータを取得しクライアントに帰します。&lt;/p>
&lt;p>違いは、クライアントが古いセグメントにあるオフセットを指定して読み込みをリクエストした場合です。
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="Storage phase-4" srcset="
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_2a2234b74cfe0781c6e5b4a49c707312.webp 400w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_0641f49b3b2042ca8b889354eab7f534.webp 760w,
/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://confluent-jp.github.io/community/community/media/blogs/kip405-why-tiered-storage-important/storage-phase-4_hu82aa3a1a927fb65a627ff1f8047c21f4_204292_2a2234b74cfe0781c6e5b4a49c707312.webp"
width="760"
height="288"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>既にBrokerのローカルストレージにはセグメントは存在しませんが、リモートストレージに存在する限りBrokerはデータを取得しクライアントに返すことが出来ます。&lt;/p>
&lt;h2 id="メリット-1---拡張性-scalability">メリット 1 - 拡張性 (Scalability)&lt;/h2>
&lt;p>Kafkaは拡張性に極めて優れたストリーミングプラットフォームであり、原則Brokerノードを追加することにより水平スケールする事ができます。一方、拡張には限界があります。一般的に大規模Kafkaクラスタにおけるボトルネックはネットワーク帯域で、次にストレージと言われています。これらを充分確保出来続ける限りKafkaクラスタは相当規模まで拡張出来ます。Tiered Storageによってストレージ容量の削減とより高度なコントロールが可能になります。&lt;/p>
&lt;p>KafkaにとってそれぞれのTopicの保全期間 (Retention Period) と書き込みスループットは基本的にはバランスゲームです - 高書き込みスループットの場合はストレージ容量の増加を加味してより短い保全期間を指定する必要があります。保全期間のデフォルトでは1週間、通常運用では1日という場合も多くありますが、高負荷のクラスタでは数時間程度に留める事も多くあります。&lt;/p>
&lt;p>kafkaは内部でデータのレプリケーションを行なっています。Replication Factorと呼ばれるこの設定のデフォルトは&lt;code>3&lt;/code>であり、稀に金融やストレッチクラスタ (複数のサイトに跨がる大きなクラスタ) では&lt;code>4&lt;/code>を指定する場合もありますが、ほとんどデフォルトのままではないかと思います。いずれにせよ、その指定分だけデータはレプリケートされるので、必要ディスク容量は増えます。&lt;/p>
&lt;p>例えば100MBpsで書き込みがなされる場合、レプリケーションも考慮するとクラスタ内のネットワーク帯域には300MBps、当然ストレージにも300MBpsのスピードで消費します。保全期間を1日とした場合、100 * 3600 * 3 = 1,080,000MB ≒ 1TBのストレージ容量が必要となります。書き込みスループットが倍になればストレージも倍、当然保全期間を倍にしてもストレージは倍必要になります。&lt;/p>
&lt;p>ストレージがボトルネックになった場合、ディスクを足せば解消しますが、それも限界を超えるとBroker自体を追加する必要が出てきます。Tiered Storageを導入すると、Brokerが必要とするストレージの絶対量を制限できます。同一ハード構成におけるキャパシティを上げ、将来的な拡張性も高く出来ます。&lt;/p>
&lt;h2 id="メリット-2---障害耐性-resiliency">メリット 2 - 障害耐性 (Resiliency)&lt;/h2>
&lt;p>ストレージを分離する事によって障害耐性が上がるというのはピンと来ないかも知れませんが、Tiered Stoargeによる効果と期待は障害耐性の向上にも集まっています。&lt;/p>
&lt;p>Kafkaが何事もなく稼働している限り、またデータが適切にパーティションされている限り、Kafkaクラスタは均一にデータを分散配置し管理出来ます。しかしBrokerのシャットダウンと復帰は必ず発生します。時としてハードやソフトの障害によって、他ではBroker/JVM/Guest OS/Host OS/Host Hardwareのアップグレードによって、クラスタ構成は短期/長期的にその構成が変わります - Kafkaは絶えずメンバーシップを変えつつ稼働し続ける分散システムであり、構成が変わる前提の上で成立している技術です。&lt;/p>
&lt;p>Brokerがクラスタメンバーから外れると、それまでそのBrokerで保全していたデータは必ず何かしらの方法で他のBrokerに再配置されなければデータの保全性が保てません。この為クラスタメンバーシップの変更は、大規模なメタデータの更新と、データの移動を意味します。&lt;/p>
&lt;p>Tiered Storageによって管理/移動対象となるセグメントの物理的な数が減れば、その分クラスタ内で移動するデータ量が減少し、また大量メタデータ更新に伴う二次災害の危険性も減少し、結果としてより安全に、より短い期間にクラスタが正常状態に復帰します。Kafkaクラスタ自体が軽量になればなるだけ、例えばコンテナの様により頻繁に刷新されるランタイム上でKafkaを運用する場合にも大きなメリットとなります。&lt;/p>
&lt;h2 id="メリット-3---リソースの有効活用-resource-utilization">メリット 3 - リソースの有効活用 (Resource Utilization)&lt;/h2>
&lt;p>Kafkaとは基本的にディスクI/Oへの負荷が高いプラットフォームです。これは書き込み/読み込みの発生頻度が高く、またディスクI/Oの有効利用が今回の設計思想に織り込まれています。併せて、Kafkaは原則マルチテナントプラットフォームであり、様々なワークロードが共存し易い (各々のワークロードの影響を受けにくい) ストリーミング基盤です。しかしながらKafkaにも物理的な制約は存在し、ワークロードのニーズ的にはクラスタ自体を分ける事も実際には多くあります。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Tiered Storageへのアクセスは、Kafkaでは珍しくディスクI/OではなくネットワークI/Oへの比重が高い処理となります。例えば長期間実行するバッチ処理 (古いデータなのでTiered Storage経由) と、超低レイテンシな処理が求められるオンライン処理 (新しいデータなのでBrokerから) とではKafkaかかるリソース負荷が全く異なります。これら特性を上手く利用すれば、オンライン処理を実行しながら低負荷でバッチ処理を同一クラスタ内で扱う事も出来ます。&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="おわりに">おわりに&lt;/h2>
&lt;p>Tiered StorageはApache Pulserの様なコンピュートとストレージを完全に切り離す目的で導入される訳ではありません。Kafkaはある意味意図的に原始的な設計をしている点が長所であり、時として短所となり得る技術です。Tiered StoargeはKafkaが本来持つ高スループットかつ低遅延な処理能力を殺す事なく、短所であるディスク容量やディスクI/Oというボトルネックを軽減させ得る可能性を持った非常に有望な機能です。併せて、よりクラウドネイティブな環境で動く機会の増えたKafkaにとって、その新しい環境により適合性の高い機能であるとも言えます。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>例えば長期実行されるバッチ処理が継続してKafkaにアクセスしている状態で、非常にレイテンシ要件の高いオンライン処理が同居する様な場合です。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>当然、充分なネットワーク帯域が確保されている場合には、という条件は付きます。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>