<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KIP | Confluent Japan Community β</title><link>https://confluent-jp.github.com/community/category/kip/</link><atom:link href="https://confluent-jp.github.com/community/category/kip/index.xml" rel="self" type="application/rss+xml"/><description>KIP</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja-jp</language><lastBuildDate>Fri, 30 Jun 2023 00:00:00 +0000</lastBuildDate><image><url>https://confluent-jp.github.com/community/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url><title>KIP</title><link>https://confluent-jp.github.com/community/category/kip/</link></image><item><title>Queues for Kafkaとは何か?</title><link>https://confluent-jp.github.com/community/blog/kip923-queues-for-kafka/</link><pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate><guid>https://confluent-jp.github.com/community/blog/kip923-queues-for-kafka/</guid><description>&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>Apache Kafka® はメッセージキューと比較される事も多く、またメッセージキューとして利用される事も多くあります。&lt;a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-932%3A&amp;#43;Queues&amp;#43;for&amp;#43;Kafka" target="_blank" rel="noopener">KIP-932 Queues for Kafka&lt;/a> はそのKafkaに対してネイティブにメッセージキューとして利用する機能性を追加するKIPです。&lt;/p>
&lt;h2 id="consumer-group">Consumer Group&lt;/h2>
&lt;p>Kafkaは仕組み的にはメッセージキューではない、と言うのは語弊があるかも知れません。もう少し正確に説明すると「メッセージの順序保証 (Order Guarantee) を確保する為にスケールする際に制限がある」仕組みを採用しています。この仕組みはConsumer Groupと呼ばれ、Kafkaにおけるデータの分離単位であるPartition単位にメッセージの順序保証をするアプローチです。&lt;/p>
&lt;p>&lt;a href="https://www.confluent.io/blog/dynamic-vs-static-kafka-consumer-rebalancing/" target="_blank" rel="noopener">Consumer Group&lt;/a>はアプリケーションが任意に指定することができ、その管理はKafka Brokerにて稼働するConsumer Group Coordinatorというプロセスが行います。Consumer Group CoordinatorはGroupメンバーの追加/削除の自動検知とリバランスを担当し、Consumer Groupメンバーの追加/離脱やこれらの死活監視、グループメンバーシップをトリガーとした処理のリバランス (メンバーへのPartitionのリアサイン) を自動的に行います。Consumer Groupの仕組みは、ストリームアプリケーションの可用性と拡張性に重要な役割を担っています。&lt;/p>
&lt;p>一方、メッセージ処理の順序保証を前提としている為、 Partitionに複数のConsumerを設定する事が出来ず、この為Topicに指定するPartition数が並列処理能力の拡張性を決定します。 また、そもそも順序性の保証が不要なユースケースであってもConsumer Groupのルールに則らないといけないという制約は存在します。大容量のデータ処理 and/or 非常に柔軟な拡張性の制御が要求されるようなユースケースでは課題となり得る、というより歯痒い条件と見られる事もあります。&lt;/p>
&lt;h2 id="これまでのアプローチ">これまでのアプローチ&lt;/h2>
&lt;p>ほとんどのユースケースでは6、10、12といったベストプラクティスに沿ったPartition数を指定する事により、充分な並列処理能力と拡張性を確保することが出来ます。仮にどれだけの並列処理能力が求められるとしても、将来的にも1処理に対して24インスタンスによる並列処理が必要となる事が無いのであれば、Partition数を24としておけば安全圏です。一般的にはこのアプローチが多く取られます。&lt;/p>
&lt;p>&lt;a href="https://github.com/line/decaton" target="_blank" rel="noopener">LINE Decaton&lt;/a> はLINE Corporationが社内利用の為に開発しオープンソース化したKafkaライブラリです。大容量のストリーム処理を安定的に、かつKey単位の順序保証とAt Least Onceのデリバリを保証する事が可能です。&lt;/p>
&lt;p>&lt;a href="https://github.com/confluentinc/parallel-consumer" target="_blank" rel="noopener">Confluent Parallel Consumer&lt;/a> はConfluentがオープンソースで提供している分散処理Kafkaライブラリです。こちらもKey単位での順序保証をしており、&lt;a href="https://www.confluent.io/blog/introducing-confluent-parallel-message-processing-client/" target="_blank" rel="noopener">順序保証しない設定を含め柔軟に処理構成を変更&lt;/a>することが出来ます。&lt;/p>
&lt;h2 id="queue-for-kafka---kafka-nativeなアプローチ">Queue for Kafka - Kafka Nativeなアプローチ&lt;/h2>
&lt;p>Queues for KafkaはConsumer Groupと異なる新しいグループ化を提供するものです。Share Groupと呼ばれ、Partition数に影響なくメンバーを追加することが出来ます。&lt;/p>
&lt;p>Shared Groupは全く異なるインターフェースではなく、これまでのConsumer Groupと同列に扱われ、&lt;code>group.type&lt;/code>を&lt;code>share&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>と設定する事によって指定します。Consumer Groupの場合、Partition数を超えるメンバーを指定しても処理に参加できなかったり、Partition数をきっちり割り切れるメンバー数でないとアサインメントに偏りが出ますが、Share Groupの場合は任意のメンバー数を指定する事により均一かつ水平にスケールします。&lt;/p>
&lt;p>Consumer Groupと構成も同じで、BrokerのうちConsumer Group CoorinatorではなくShare Group Coordinatorを司るプロセスがグループメンバーの死活監視、リバランス等をConsumer Group同様に実施します。アプリケーション観点でもデプロイ観点でも、Consuemr Groupとの差はなく、あくまでプロパティ設定するのみでグループの振る舞いを変えることができます。&lt;/p>
&lt;h2 id="おわりに">おわりに&lt;/h2>
&lt;p>Kafkaというはそのシンプルな設計ゆえに、十分理解しないと活用が難しいイメージがありました。ただこのシンプルさによってスケーラビリティとあらゆるユースケースでの活用することができ、Kafkaの理解を深める事はより良い設計をする上で非常に重要です。KIP-932は、Kafka誕生から変わることの無かったConsumer Groupというアプローチとは異なるデータアクセスのパターンに対する変更という意味では非常に興味深いKIPです。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;code>group.type&lt;/code>は新しいプロパティ。デフォルトは&lt;code>consumer&lt;/code>であり、この指定だと通常通りConsumer Groupとして機能する。デフォルトは&lt;code>consumer&lt;/code>である為下位互換性あり。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>